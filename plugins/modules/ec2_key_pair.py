#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright: (c) 2020, XLAB Steampunk <steampunk@xlab.si>
# Proprietary software, see LICENSE file.


from __future__ import absolute_import, division, print_function

__metaclass__ = type

ANSIBLE_METADATA = {
    "metadata_version": "1.1",
    "status": ["preview"],
    "supported_by": "XLAB Steampunk",
}

# language=yaml
DOCUMENTATION = """
module: ec2_key_pair
author:
  - Manca Bizjak (@mancabizjak)
  - Aljaz Kosir (@aljazkosir)
  - Saso Stanovnik (@sstanovnik)
  - Miha Dolinar (@mdolinar)
  - Tadej Borovsak (@tadeboro)
short_description: Manage EC2 key pairs.
description:
  - Create, delete or update an EC2 key pair.
  - Note that EC2 only supports RSA key pairs size 1024, 2048 and 4096.
extends_documentation_fragment:
  - steampunk.aws.auth
  - steampunk.aws.state
options:
  name:
    description:
      - The name of the AWS EC2 key pair.
    required: true
    type: str
  public_key:
    description:
      - The public key in the OpenSSH public key format, i.e. the format in ~/.ssh/authorized_keys
        and ~/.ssh/*.pub.
      - Specify this parameter if you have created a key pair yourself instead of having EC2 create
        it for you.
      - If this parameter is omitted, the playbook author must ensure that the remotely-generated
        private key is stored.
      - Important - when using I(public_key) with a key pair that already exists on AWS, generated
        by AWS, this module creates a duplicate key.
        There is no way to avoid this, as there is no way of determining whether a key pair that
        was generated by AWS matches a key pair generated locally.
        This is due to AWS computing fingerprints differently for the two types - SHA1 on the
        private key and MD5 on the public key - and because AWS never returns public keys, only
        fingerprints.
    type: str
  fingerprints:
    description:
      - The MD5 fingerprint of I(public_key).
      - There is no need to specify a fingerprint. If any fingerprints are provided, and none match
        the I(public_key), this module errors out.
    required: false
    type: list
  force:
    description:
      - If "true", this module allows overwriting a key pair with the same name but different
        contents that already exists on AWS EC2.
      - Additionally, if I(public_key) is not specified, I(force=true) always recreates the key
        pair.
    default: false
    type: bool
seealso:
  - module: ec2_key_pair_info
"""

# language=yaml
EXAMPLES = """
- name: Create an EC2 key pair through EC2
  ec2_key_pair:
    name: my-first-keypair
  register: first_keypair
- name: Store the generated private key.
  copy:
    path: /tmp/my-first-keypair.key
    content: "{{ first_keypair.object.key_material }}"

- name: Generate a key pair locally
  openssh_keypair:
    path: /tmp/my-local-keypair
- name: Upload the public key to EC2 as a new key pair
  ec2_key_pair:
    name: my-local-keypair
    public_key: "{{ lookup('file', '/tmp/my-local-keypair.pub') }}"

- name: Remove an EC2 key pair
  ec2_key_pair:
    name: my-local-keypair
    state: absent
"""

# language=yaml
RETURN = """
object:
  description:
    - An object representing an EC2 key pair.
  type: dict
  returned: success
  contains:
    name:
      description: The name of the key pair.
      type: str
      returned: always
    fingerprint:
      description:
        - This keypair's fingerprint.
        - Note that AWS computes fingerprints in two different ways -
          for AWS-generated keys, fingerprints are computed with SHA1 on the _private_ keys,
          while for imported keys, fingerprints are computed with MD5 on the _public_ keys.
      type: str
      returned: always
    key_material:
      description: The private key material when this key pair was generated by AWS.
      type: str
      returned: when first generated by AWS
  sample:
    object:
      name: my-first-keypair
      fingerprint: "0a:ec:24:7b:69:ce:98:63:a4:ea:3c:e6:76:bb:6c:66:90:d0:33:ae"
      key_material: "-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAphtK07bud2MvFYN8nKgSlxX/7hDwTrI8ibA3HnfVtFEY3lMvX3Ytz0jGEIwT\nMBclb5B6Bn0kJCeF4scd9PRfJC8WSM+mb0pKTKINqGkAOTpIWOI5Hy/A6ZOxzayK7sM7PamYCmMv\npbC0BuFmNQW3njzzM3kPQwfKrk+UeH7/vLVL1Fs9Ruh49i13Gb6z6QAIVThvPIQdnl2VnZibFRfr\nIKvckjkwrGv11QxVHkhA9MNu476Y/P9L0Ry9tULXFf6YcWp8g279ACn4rLDiiNj544caBlfoI6fC\nP3ZF+CTFaiYooRTqeQnSYW+84QO4xDab04Y2u5urppqnCifx+I/IaQIDAQABAoIBADcDzxK0AeNU\n3GFZvUn9eLrFtJBa19yYt+g6jubudb9VJNFt58DMWXvP9JnCaxCAegurZF8Fz5SR6owjus5IqcJI\nPi87Zzpw9o7PFYrzy/koTpHxy02C+XfjTP576UAPNW3E3/CAzWUpU1b8DGf/TsOAGGSx8dYXnI+D\nF/+YwIb1U8yoHqa4vmL55gBiQLd+gWAIkEqTnSLoZlG8jBcDii2BLoz0MfVK6Zbk6uHkJ+DgOQtu\nYEFX0/YbsNThNJkHTRJxSG8a0EVG4EdeAeKlJUJdYUPY0nuUabYVRbwbAan1KQRslmFD1cMj1pV8\nbaWtctm+AwpPwBpfERDApxZhgaECgYEA4h0VZM/zhr001rgEUng8RBvbXr4OLwmN0JEjF5gowQ28\nHZv7t9bFpkRFjibbViJpEWv2XXWg8eVm9UIGY6RZs4jRpfYNu78b1UeVUczf1DzX4gAOkt7DK+Ao\nLQlPeEIDSzw+F2gwWFdGVw8GhKVbhu2rczGYcS6HPWwi1yDbhp0CgYEAvA/GmMRtQVb+y4VRu0Qx\nUoAOrYdy5HrAnJ4InDCVnEZFfMvL7rWndMoi6hRVAHaYPLteU4tsuXntCdpQpf15g8bEiUYJBQ5+\nI5q4Ps494iv474AwHRn50y0ZKw5KcR31xtlGIGOL3DmN+uFnVgPhwDP9wlUSagValYQ92/36+T0C\ngYBQ7jn3EFtIsbYU2F5rqi9f7VySR5JKEbBZo2kdC9AicSkQrADnpw6tWShQHeZJqR1UKAFRKEYH\n7qTwScaBqZSVpvXq4eu+dEOhDfMLCTpf+7sFYCHXPbY7oQqgPAHeuDn3lsNem2Maa3p4tJ8PoSPm\nYnEIVQsMD6xGNsstlswcHQKBgQCAz6luz/QpsgW5ryqJQy8pXA8xqrn2Z2HwpIovOVPwg21rCkg3\ny/LUGvQJMz35oEGsL4ZvYOtqq2nBuuhMma6WpRnPEMpyzTd2+a3DTw6yEP5kRYAvHrCwhY5coGA6\n1JOYzQ+sdaLBiCaItcVK9EO3m6Tva8e+GMav7LFWMsOp3QKBgEW6spzn3phkQxSJ/PI2gXQXgCGt\nxEjoXrrRxvhX9F2+AwM9osQCk81b36hvp4Ml4OyHSuYkmQoULRCum2e9SYo/bXIdaGNo/4ImJ1Up\nMBbjB+4TLv3ywGU/mUcKgoBJra9M45qbBAfXZu74TVPs6k2EPCm4OltIZjNk5uba2908\n-----END RSA PRIVATE KEY-----"  # noqa
"""

from ansible.module_utils.basic import AnsibleModule

from ansible_collections.steampunk.aws.plugins.module_utils import spec, boto, ec2_filters, errors
from ansible_collections.steampunk.aws.plugins.module_utils.ec2_key_pair_utils import \
    fingerprints_equal, boto_dict_to_module_return

try:
    from botocore.exceptions import ClientError

    HAS_BOTO3 = True
except ImportError:
    HAS_BOTO3 = False


def lookup_existing_keypair(client, key_name):
    """
    :type client: pyboto3.ec2
    :type key_name: str
    :rtype: typing.Optional[dict]
    """
    try:
        keys_struct = client.describe_key_pairs(KeyNames=[key_name])
        keys = keys_struct["KeyPairs"]
    except ClientError:
        # a query for a specific name found nothing
        keys = []

    if not keys:
        return None

    return keys[0]


def _create_keypair_new(client, key_name, public_key_material, check_mode):
    if check_mode:
        return None, True
    else:
        # fingerprints are not important here and have been checked in the action plugin
        if public_key_material is None:
            response_object = client.create_key_pair(KeyName=key_name)
        else:
            response_object = client.import_key_pair(KeyName=key_name,
                                                     PublicKeyMaterial=public_key_material)
        waiter = client.get_waiter("key_pair_exists")
        waiter.wait(Filters=ec2_filters.from_dict({"key-name": key_name}))
        return response_object, True


def _update_keypair(client, key_name, public_key_material, fingerprints, force, check_mode,
                    existing_keypair):
    response_object = existing_keypair
    changed = False
    warning = None
    if public_key_material is None:
        if force:
            changed = True
            if check_mode:
                # we don't want to return the initial object, as that'd be incorrect
                response_object = None
            else:
                client.delete_key_pair(KeyName=key_name)
                response_object = client.create_key_pair(KeyName=key_name)
                waiter = client.get_waiter("key_pair_exists")
                waiter.wait(Filters=ec2_filters.from_dict({"key-name": key_name}))
        else:
            warning = "Any subsequent invocation of this module does not return the remotely-" \
                      "generated private key as only the initial generation creates it!"
    else:
        # existing_key with same name exists, public_key specified
        local_fingerprint_matches_existing_keypair = \
            any(fp for fp in fingerprints
                if fingerprints_equal(fp, existing_keypair["KeyFingerprint"]))

        if local_fingerprint_matches_existing_keypair:
            # the fingerprint now MUST be MD5, as there is no way to have a local SHA1 fingerprint
            # do nothing, locally-generated key already present
            pass
        else:
            if force:
                changed = True
                if check_mode:
                    # same argumentation as above
                    response_object = None
                else:
                    client.delete_key_pair(KeyName=key_name)
                    response_object = client.import_key_pair(KeyName=key_name,
                                                             PublicKeyMaterial=public_key_material)
            else:
                raise errors.DisallowedOperationError(
                    "A key pair with name {0} already exists. Set force: true to overwrite.".format(
                        key_name))

    return response_object, changed, warning


def create_keypair(client, key_name, public_key_material, fingerprints, force, check_mode):
    """
    :type client: pyboto3.ec2
    :type key_name: str
    :type public_key_material: typing.Optional[str]
    :type fingerprints: typing.Optional[typing.List[str]]
    :type force: bool
    :type check_mode: bool

    :return: (changed, object, warning)
    :rtype: typing.Tuple[bool, dict, str]
    """
    existing_keypair = lookup_existing_keypair(client, key_name)

    warning = None
    if existing_keypair is None:
        response_object, changed = _create_keypair_new(client, key_name, public_key_material,
                                                       check_mode)
    else:
        response_object, changed, warning = _update_keypair(client, key_name, public_key_material,
                                                            fingerprints, force, check_mode,
                                                            existing_keypair)
    return changed, response_object, warning


def delete_keypair(client, key_name, check_mode):
    """
    :type client: pyboto3.ec2
    :type key_name: str
    :type check_mode: bool

    :return: changed
    :rtype: bool
    """
    existing_key = lookup_existing_keypair(client, key_name)
    if existing_key is None:
        # do nothing, already deleted
        return False

    if not check_mode:
        client.delete_key_pair(KeyName=key_name)
    return True


def main():
    module = AnsibleModule(
        supports_check_mode=True,
        argument_spec=dict(
            name=dict(
                required=True
            ),
            public_key=dict(),
            fingerprints=dict(
                type="list"
            ),
            force=dict(
                type="bool",
                default=False
            ),
            **spec.params("auth", "state")
        ),
        required_by=dict(
            fingerprints=["public_key"]
        )
    )

    # TODO: enable moving keypairs between regions because boto supports that?

    changed = False
    result = None
    try:
        client = boto.ec2_client(module.params["auth"])

        if module.params["state"] == "present":
            changed, response_object, warning = create_keypair(
                client,
                module.params["name"],
                module.params["public_key"],
                module.params["fingerprints"],
                module.params["force"],
                module.check_mode
            )
            if warning is not None:
                module.warn(warning)
            result = boto_dict_to_module_return(response_object) \
                if response_object is not None else None
        else:
            changed = delete_keypair(client, module.params["name"], module.check_mode)
    except errors.AwsCollectionError as e:
        module.fail_json(msg="{0}: {1}".format(e.__class__.__name__, str(e)))
    module.exit_json(changed=changed, object=result)


if __name__ == "__main__":
    main()
